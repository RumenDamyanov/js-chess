// PGN generation, save slots, autosave & import for jQuery version
(function(){
  const SAVE_KEY='jquerySaveSlotsV2';
  const AUTOSAVE_KEY='jqueryAutosaveV2';
  let saveSlots={};
  let chessReady=false;
  function loadSlots(){ try{ saveSlots=JSON.parse(localStorage.getItem(SAVE_KEY)||'{}')||{} }catch{ saveSlots={} } updateSlotLabels(); }
  function persistSlots(){ localStorage.setItem(SAVE_KEY, JSON.stringify(saveSlots)) }
  function snapshot(){ if(!window.chessGame || !window.chessGame.gameId) return null; const gs = window.chessGame.gameState||{}; return { gameId: window.chessGame.gameId, move_history: gs.move_history||[], status: gs.status||'unknown', active_color: gs.active_color||'white', whiteTime: window.gameConfig?.timers.white||0, blackTime: window.gameConfig?.timers.black||0, orientation: window.gameConfig?.getPlayerColor?.()||'white', fen: gs.fen || window.chessGame.currentFEN || '', savedAt: Date.now() }; }
  function generatePGN(){ if(!window.chessGame?.gameState?.move_history?.length){ setPGN(''); return } const playerName=window.JSChessPlayer?.getName?.()||'Player'; const text=window.JSChessPGN.build(window.chessGame.gameState,{ white:playerName, black:'AI' }); setPGN(text); }
  function setPGN(text){ const out=document.getElementById('pgn-output'); if(out) out.value=text; const disabled=!text; ['pgn-copy-btn','pgn-download-btn','pgn-refresh-btn'].forEach(id=>{ const btn=document.getElementById(id); if(btn) btn.disabled=disabled; }); }
  function legacyCopy(txt){ const ta=document.createElement('textarea'); ta.style.position='fixed'; ta.style.opacity='0'; ta.value=txt; document.body.appendChild(ta); ta.select(); try{ document.execCommand('copy'); }catch{} document.body.removeChild(ta); }
  function copyPGN(){ const out=document.getElementById('pgn-output'); if(!out||!out.value) return; (navigator.clipboard?navigator.clipboard.writeText(out.value).catch(()=>legacyCopy(out.value)):legacyCopy(out.value)); message('PGN copied','success'); }
  function downloadPGN(){ const out=document.getElementById('pgn-output'); if(!out||!out.value) return; const blob=new Blob([out.value],{type:'text/plain'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`game-${Date.now()}.pgn`; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),2000); message('PGN downloaded','info'); }
  function refreshPGN(){ generatePGN(); message('PGN regenerated','info'); }
  function updateSlotLabels(){ for(let i=1;i<=3;i++){ const el=document.getElementById(`slot-${i}-time`); if(!el) continue; const data=saveSlots[i]; el.textContent = data ? new Date(data.savedAt).toLocaleTimeString() : 'Empty'; } }
  function updateSlotButtonsState(){ document.querySelectorAll('.save-slots button[data-action]').forEach(btn=>{ if(!chessReady){ btn.disabled=true; return; } const slot=btn.getAttribute('data-slot'); const action=btn.getAttribute('data-action'); const has=!!saveSlots[slot]; if(action==='save'){ btn.disabled=false; } else { btn.disabled=!has; } }); }
  function saveSlot(n){ if(!window.chessGame||!window.chessGame.gameId){ message('No active game','error'); return; } if(saveSlots[n] && !confirm(`Overwrite slot ${n}?`)) return; const snap=snapshot(); if(!snap){ message('Nothing to save','warning'); return; } saveSlots[n]=snap; persistSlots(); updateSlotLabels(); generatePGN(); message(`Saved to slot ${n}`,'success'); updateSlotButtonsState(); }
  async function loadSlot(n){ const data=saveSlots[n]; if(!data){ message('Empty slot','warning'); return; } message(`Loading slot ${n}...`,'info'); if(data.orientation && window.gameConfig){ document.getElementById('player-color').value=data.orientation; window.gameConfig.config.playerColor=data.orientation; window.gameConfig.updateBoardOrientation(); window.gameConfig.updateOrientationIndicator(); } await window.chessGame.startNewGame({suppressAIMove:true}); for(const mv of data.move_history){ try{ await window.chessGame.api.makeMove(window.chessGame.gameId,{from:mv.from,to:mv.to}); const st=await window.chessGame.api.getGame(window.chessGame.gameId); window.chessGame.gameState=st; window.chessGame.currentFEN=st.fen; window.chessGame.updateBoard(); window.chessGame.updateGameInfo(); window.chessGame.updateMoveHistory(); }catch(e){ Debug && Debug.warn && Debug.warn('slotReplay','Replay move failed', mv, e); break; } } window.gameConfig.timers.white=data.whiteTime||0; window.gameConfig.timers.black=data.blackTime||0; window.gameConfig.updateTimerDisplay(); generatePGN(); message(`Slot ${n} loaded`,'success'); }
  function deleteSlot(n){ if(!saveSlots[n]) return; if(!confirm(`Delete slot ${n}?`)) return; delete saveSlots[n]; persistSlots(); updateSlotLabels(); updateSlotButtonsState(); message(`Slot ${n} deleted`,'info'); }
  function autosave(){ const snap=snapshot(); if(!snap) return; localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(snap)); }
  function tryRestoreAutosave(){ try{ const raw=localStorage.getItem(AUTOSAVE_KEY); if(!raw) return; const data=JSON.parse(raw); if(!data.move_history?.length) return; message('Restoring autosave...','info'); (async()=>{ if(data.orientation && window.gameConfig){ document.getElementById('player-color').value=data.orientation; window.gameConfig.config.playerColor=data.orientation; window.gameConfig.updateBoardOrientation(); window.gameConfig.updateOrientationIndicator(); } await window.chessGame.startNewGame({suppressAIMove:true}); for(const mv of data.move_history){ try{ await window.chessGame.api.makeMove(window.chessGame.gameId,{from:mv.from,to:mv.to}); const st=await window.chessGame.api.getGame(window.chessGame.gameId); window.chessGame.gameState=st; window.chessGame.currentFEN=st.fen; window.chessGame.updateBoard(); window.chessGame.updateGameInfo(); window.chessGame.updateMoveHistory(); }catch(e){ Debug && Debug.warn && Debug.warn('autosaveReplay','Replay move failed', mv, e); break; } } window.gameConfig.timers.white=data.whiteTime||0; window.gameConfig.timers.black=data.blackTime||0; window.gameConfig.updateTimerDisplay(); generatePGN(); message('Autosave restored','success'); })(); }catch{} }
  function message(msg,type='info'){ if(window.JSChessMessages){ window.JSChessMessages.showMessage(msg,type,{duration:2000}); } }
  function handleMoveChange(){ generatePGN(); autosave(); }
  function bindUI(){ document.getElementById('pgn-copy-btn')?.addEventListener('click',copyPGN); document.getElementById('pgn-download-btn')?.addEventListener('click',downloadPGN); document.getElementById('pgn-refresh-btn')?.addEventListener('click',refreshPGN); document.querySelectorAll('.save-slots button[data-action]').forEach(btn=>{ btn.addEventListener('click',()=>{ const slot=parseInt(btn.getAttribute('data-slot'),10); const action=btn.getAttribute('data-action'); if(action==='save') saveSlot(slot); else if(action==='load') loadSlot(slot); else if(action==='delete') deleteSlot(slot); }); }); const toggle=document.getElementById('pgn-import-toggle'); const panel=document.getElementById('pgn-import-panel'); const input=document.getElementById('pgn-import-input'); const run=document.getElementById('pgn-import-run'); const clear=document.getElementById('pgn-import-clear'); if(toggle) toggle.addEventListener('click',()=>{ const opening = panel.style.display==='none'; panel.style.display= opening ? 'block':'none'; toggle.textContent= opening ? 'Close':'Import'; toggle.setAttribute('aria-expanded', opening ? 'true':'false'); }); if(input) input.addEventListener('input',()=>{ const has=!!input.value.trim(); run.disabled=!has; clear.disabled=!has; }); if(clear) clear.addEventListener('click',()=>{ input.value=''; run.disabled=true; clear.disabled=true; }); if(run) run.addEventListener('click',()=>importPGN(input.value.trim())); }
  async function importPGN(text){ if(!text) return; const moves=window.JSChessPGN.parseCoordinateMoves(text); if(!moves.length){ message('No importable moves','error'); return } await window.chessGame.startNewGame({suppressAIMove:true}); for(const mv of moves){ try{ await window.chessGame.api.makeMove(window.chessGame.gameId,{from:mv.slice(0,2),to:mv.slice(2,4)}); const st=await window.chessGame.api.getGame(window.chessGame.gameId); window.chessGame.gameState=st; window.chessGame.currentFEN=st.fen; window.chessGame.updateBoard(); window.chessGame.updateGameInfo(); window.chessGame.updateMoveHistory(); }catch(e){ Debug && Debug.warn && Debug.warn('importReplay','Replay move failed', mv, e); break; } } generatePGN(); message('PGN imported','success'); const panel=document.getElementById('pgn-import-panel'); if(panel) panel.style.display='none'; const toggle=document.getElementById('pgn-import-toggle'); if(toggle) toggle.textContent='Import'; const input=document.getElementById('pgn-import-input'); if(input) input.value=''; }
  // Monkey patch ChessGameJQuery (not base ChessGame) after it exists
  const patchInterval=setInterval(()=>{
    if(window.chessGame && window.chessGame.updateMoveHistory){
      const proto=window.chessGame.__proto__;
      if(!proto.__pgnPatched){
        const origUpdate=proto.updateMoveHistory; proto.updateMoveHistory=function(){ origUpdate.apply(this,arguments); handleMoveChange(); };
        const origStart=proto.startNewGame; proto.startNewGame=async function(){ await origStart.apply(this,arguments); chessReady=true; updateSlotButtonsState(); handleMoveChange(); };
        proto.__pgnPatched=true;
      }
      clearInterval(patchInterval);
    }
  },120);
  document.addEventListener('DOMContentLoaded',()=>{ loadSlots(); bindUI(); updateSlotButtonsState(); tryRestoreAutosave(); const readyCheck=setInterval(()=>{ if(window.chessGame && window.chessGame.gameId){ if(!chessReady){ chessReady=true; updateSlotButtonsState(); handleMoveChange(); } clearInterval(readyCheck);} },150); setTimeout(()=>clearInterval(readyCheck),5000); });
})();
